\documentclass{article}
\usepackage{titlepage}
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\graphicspath{{image/}}
\usepackage{geometry}
\geometry{
	right=20mm,
	left=20mm
}
\renewcommand{\baselinestretch}{1.6}

\title{Tests unitaires}
\subtitle{TP1}
\dateremise{le 2 Octobre 2018}
\author{Billy Bouchard}{Jacob Dorais}{}
\prof{Hiba Bagane}


\begin{document}
\maketitle
\section*{Stub, Spy et Mock}
Malgré que ces 3 éléments permettent de créer de fausses fonctions et de faux objets lors des différents test, il devient très rapidement difficile d'identifier lesquels servent dans quelles cas.
En effet, ces trois objets ont différent but dans les test et il est important de connaitre leur role.
Le spy permet d'observer le comportement d'une fonction,
Le stub permet d'en empecher l'execution et le mock permet même de plannifier d'avance les appels voulu.
\subsection*{Spy}
Le spy permet d'observer le comportement d'une méthode sans en modifier l'exécution.
Cela peut rapidement devenir utile lorsqu'on veux connaitre les arguments de la fonction utiliser ou encore tout simplement savoir combien de fois cette dernière a été appelé.
Malgré qu'il ne faut pas utiliser de spy lorsqu'on a l'intention de vouloir modifier le fonctionnement d'une méthode ou d'une fonction, on peut quand même observer tout les appels qui lui ont été faites.
Il s'agit donc ici d'un "wrapper" qui enregistre tout les entrée et sortie de la fonction ainsi que les appels, mais qui ne change pas son comportement.
\subsection*{Stub}
Le stub permet de faire la même chose que le spy, mais en plus il empêche l'execution de la méthode.
En fait, il permet plutot de remplacer l'implementation de base de la méthode par une plus simple qui fera exactement ce que l'on veut.
Les stub sont donc des spy qui au lieu de "wrapper", remplace simplement la fonction(ou methode) par une autre implémentation.
Il sont extrêmement utile lorsque l'on veux éviter de tester une  méthode ou fonction dont l'implémentation cascade sur une dizaine de méthode.
On peut donc juste forcer le résultat de la première fonction plutot que de trouver quelle valeur envoyer
\subsection*{Mock}
Le Mock est le plus complet des modificateur utilisé pour les test unitaires.
Ce dernier permet non seulement d'observer le comportement d'une méthode, mais aussi de lui donné le comportement désiré de l'appelant envers elle.
Il devient donc possible de modifier le retour du mock en fonction des arguments qui lui sont passer.
Contrairement au spy, le test echouera automatiquement si les parametres attendu ne sont pas respecté lors des appels.
Le Mock est donc un stub dans lequels on ajoutes des attentes notamment quant au nombre d'appel et aux arguments avec lesquels les appels sont fait.
Ainsi, le Mock est très utile lorsqu'on veut controller comment la méthode tester utilise notre mock.
\section*{Question}
\subsection*{Quelle méthode avez vous choisi pour empêcher la classe JsonClient d’exécuter
  les vrais appels API durant vos tests unitaires?}
Nous avons choisis d'utiliser un stub de la method fetch de l'objet nodeFetch.
Il s'agit d'une modification de la méthode qui remplace la définition utilisée dans le code de base.
Un stub permet donc de remplacer complètement l'implementation de la méthode fetch de l'objet nodeFetch.
On peux alors choisir de renvoyer les réponse que l'on veux, que se soit une promesse ou une simple valeur de retour.
Dans le cas du programme actuel, on utilise le stub pour envoyer des prommesse et éviter de faire de vrai requette http.
On peux alors controler les paramètre des promesses afin de s'assurer que les résultats voulues soit appeler.
On peux aussi choisir de faire différent retour en fonction de la nombre de fois que la fonction est appeler.
Ainsi, on peux choisir de retourner certaines données lors du premier appel et d'autre données lors du second.
Le tout nous permet d'obtenir des test encore plus précis sur certaines méthodes.
\subsection*{Quelle méthode avez vous choisi pour empêcher la classe Client d’exécuter les
  vrais appels API contenus dans les méthodes de la classe JsonClient durant
  vos tests unitaires?}
Pour la majorité des appels, nous avons fait la même chose que pour la classe JsonClient.
Nous avons donc utiliser un Stub de certaine méthode de la classe JsonClient.
La fonction stub changeais souvent en fonction des fonctions tester, par conséquent elle était souvent différente.
Cependant, pour certaine des fonctions, il est devenu plus utile de faire des Spy sur ces dernières.
En effet, puisqu'il peux y avoir plus qu'un appel de ses sous méthodes, il est devenu important d'observer le nombre de fois où elles ont été appelée et les arguemnts avec lesquels elle ont été appelé.
Ainsi, on ne change pas le fonctionnement de la méthode mais on peux au moins savoir si elle a été appeler avec les bons arguments ou encore si elle a été appelé le bon nombre de fois.
Un exemple d'utilisation que nous avons fait a été pour verififer si une des méthodes testé lancais une erreur.
\subsection*{Est-ce que vos tests unitaires ont découvert une ou plusieurs défaillances? Si oui,
  expliquez ce que vous avez trouvé?}
Oui, ils ont trouver un total de 3 défaillances dans le code.
les deux première défaillances sont lié au fait qu'une méthode n'a pas été implémentée pour l'objet sharedbox.
En effet, la méthode toObject sur un objet shareBox n'existe pas.
Ainsi, en essayant de l'appeler, le programme lance une erreur.
\subsection*{Le projet implémente un type d’exceptions personnalisé SharedBoxException
  qui étend le type standard Error. Lorsque vous avez testé les exceptions qui
  peuvent être lancées par la classe Client, était-il possible de vérifier le type de
  l’exception? Si non, expliquez pourquoi et proposez une solution.}

\end{document}
