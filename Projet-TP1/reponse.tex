\documentclass{article}
\usepackage{titlepage}
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\graphicspath{{image/}}
\usepackage{geometry}
\geometry{
	right=20mm,
	left=20mm
}
\renewcommand{\baselinestretch}{1.6}

\title{Tests unitaires}
\subtitle{TP1}
\dateremise{le 2 Octobre 2018}
\author{Billy Bouchard}{Jacob Dorais}{}
\prof{Hiba Bagane}


\begin{document}
\maketitle
\section*{Stub, Spy et Mock}
Malgré que ces 3 éléments permettent de créer de fausses fonctions et de faux objets lors des différents test, il devient très rapidement difficile d'identifier lesquels servent dans quelles cas.
En effet, ces trois objets ont différent but dans les test et il est important de connaitre leur role.
Le spy permet d'observer le comportement d'une fonction,
Le stub permet d'en empecher l'execution et le mock permet même de plannifier d'avance les appels voulu.
\subsection*{Spy}
Le spy permet d'observer le comportement d'une méthode sans en modifier l'exécution.
Cela peut rapidement devenir utile lorsqu'on veux connaitre les arguments de la fonction utiliser ou encore tout simplement savoir combien de fois cette dernière a été appelé.
Malgré qu'il ne faut pas utiliser de spy lorsqu'on a l'intention de vouloir modifier le fonctionnement d'une méthode ou d'une fonction, on peut quand même observer tout les appels qui lui ont été faites.
Il s'agit donc ici d'un "wrapper" qui enregistre tout les entrée et sortie de la fonction ainsi que les appels, mais qui ne change pas son comportement.
\subsection*{Stub}
Le stub permet de faire la même chose que le spy, mais en plus il empêche l'execution de la méthode.
En fait, il permet plutot de remplacer l'implementation de base de la méthode par une plus simple qui fera exactement ce que l'on veut.
Les stub sont donc des spy qui au lieu de "wrapper", remplace simplement la fonction(ou methode) par une autre implémentation.
\subsection*{Mock}
Le Mock est le plus complet des modificateur utilisé pour les test unitaires.
Ce dernier permet non seulement d'observer le comportement d'une méthode, mais aussi de lui donné le comportement désiré de l'appelant envers elle.
Il devient donc possible de modifier le retour du mock en fonction des arguments qui lui sont passer.
Contrairement au spy, le test echouera automatiquement si les parametres attendu ne sont pas respecté lors des appels.
Le Mock est donc un stub dans lequels on ajoutes des attentes notamment quant au nombre d'appel et aux arguments avec lesquels les appels sont fait.
Ainsi, le Mock est très utile lorsqu'on veut controller comment la méthode tester utilise notre mock.
\section*{Question}
\subsection*{Quelle méthode avez vous choisi pour empêcher la classe JsonClient d’exécuter
  les vrais appels API durant vos tests unitaires?}
Nous avons choisis d'utiliser un stub de la method fetch de l'objet nodeFetch.
Il s'agit d'une modification de la méthode qui remplace la définition utilisée dans le code de base.
Un stub permet donc de remplacer complètement l'implementation de la méthode fetch de l'objet nodeFetch.
On peux alors choisir de renvoyer les réponse que l'on veux, que se soit une promesse ou une simple valeur de retour.
Dans le cas du programme actuel, on utilise le stub pour envoyer des prommesse et éviter de faire de vrai requette http.
On peux alors controler les paramètre des promesses afin de s'assurer que les résultats voulues soit appeler.
On peux aussi choisir de faire différent retour en fonction de la nombre de fois que la fonction est appeler.
Ainsi, on peux choisir de retourner certaines données lors du premier appel et d'autre données lors du second.
Le tout nous permet d'obtenir des test encore plus précis sur certaines méthodes.
\subsection*{Quelle méthode avez vous choisi pour empêcher la classe Client d’exécuter les
  vrais appels API contenus dans les méthodes de la classe JsonClient durant
  vos tests unitaires?}
\end{document}
